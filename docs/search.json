[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Géomatique avec R",
    "section": "",
    "text": "Préambule\nCe manuel est destiné tant aux utilisateurs de R souhaitant mettre en place des traitements de données spatiales qu’aux utilisateurs souhaitant utiliser R pour réaliser les taches qu’ils réalisent habituellement avec un SIG.\nLes principales étapes du traitement de l’information géographiques y sont abordées. L’accent est porté sur le traitement des données vectorielles mais une partie est tout de même dédiée aux données raster.\nComment utiliser le manuel\nLes données utilisées dans ce document sont stockées dans un projet RStudio. Vous devez le télécharger puis le décompresser sur votre machine. Il vous sera ensuite possible de tester l’ensemble des manipulations proposées dans ce document au sein du projet geodata.\nTélécharger le projet\nContribution et feedback\nVous pouvez nous envoyer vos remarques et suggestions en postant une issue sur le dépôt GitHub de ce document.\nContexte\nCe manuel a été initialement conçu pour accompagner le cours “Cartographie avec R” du Master 2 Géomatique, géodécisionnel, géomarketing et multimédia (G2M) de l’Université Paris 8 Vincennes - Saint-Denis. Un deuxième manuel centré sur la cartographie est disponible ici : Cartographie avec R.\n\n Pour citer le document :\nGiraud, T. et Pecout, H. (2023). Géomatique avec R. https://doi.org/10.5281/zenodo.5906212\n@misc{\n  author = {Giraud, Timothée and Pecout, Hugues},\n  doi = {10.5281/zenodo.5906212},\n  title = {{Géomatique avec R}},\n  url = {https://rcarto.github.io/geomatique_avec_r/},\n  year = {2023}\n}"
  },
  {
    "objectID": "01_package_sf.html#présentation",
    "href": "01_package_sf.html#présentation",
    "title": "1  Le package sf",
    "section": "1.1 Présentation",
    "text": "1.1 Présentation\n Le package sf (Pebesma, 2018) a été publié fin 2016 par Edzer Pebesma. Ce package permet l’import, l’export, la manipulation et l’affichage de données spatiales vectorielles. Pour cela sf s’appuie sur une série de bibliothèques spatiales : GDAL (GDAL/OGR contributors, 2022) et PROJ (PROJ contributors, 2021) pour les opérations d’import, d’export et de projection, et GEOS (GEOS contributors, 2021) pour les opérations de géotraitement (buffer, intersection…).\nCe package propose des objets simples (suivant le standard simple feature) dont la manipulation est assez aisée. Une attention particulière a été portée à la compatibilité du package avec la syntaxe pipe (|&gt; ou %&gt;%) et les opérateurs du tidyverse (Wickham et al., 2019).\n\n\n\nPebesma et Bivand (2023)\n\n\n\n\n\n\n\n\nHistorique\n\n\n\nLe package sf est venu remplacer les packages sp (Pebesma et Bivand, 2005), rgeos (Bivand et Rundel, 2023) et rgdal (Bivand et al., 2023) en combinant leurs fonctionnalités dans un package unique plus ergonomique."
  },
  {
    "objectID": "01_package_sf.html#format-des-objets-sf",
    "href": "01_package_sf.html#format-des-objets-sf",
    "title": "1  Le package sf",
    "section": "1.2 Format des objets sf",
    "text": "1.2 Format des objets sf\n\nLes objets sf sont des data.frame dont l’une des colonnes contient des géométries. Cette colonne est de la classe sfc (simple feature column) et chaque individu de la colonne est un sfg (simple feature geometry).\nCe format est très pratique dans la mesure ou les données et les géométries sont intrinsèquement liées dans un même objet.\n\n\n\n\n\n\nVignette décrivant le format simple feature\n\n\n\nSimple Features for R\n\n\n\n\n\n\nBivand, R., Keitt, T. et Rowlingson, B. (2023). rgdal: Bindings for the ’Geospatial’ Data Abstraction Library. https://CRAN.R-project.org/package=rgdal\n\n\nBivand, R. et Rundel, C. (2023). rgeos: Interface to Geometry Engine - Open Source (’GEOS’). https://CRAN.R-project.org/package=rgeos\n\n\nGDAL/OGR contributors. (2022). GDAL/OGR Geospatial Data Abstraction software Library. Open Source Geospatial Foundation. https://doi.org/10.5281/zenodo.5884351\n\n\nGEOS contributors. (2021). GEOS coordinate transformation software library. Open Source Geospatial Foundation. https://libgeos.org/\n\n\nPebesma, E. (2018). Simple Features for R: Standardized Support for Spatial Vector Data. The R Journal, 10(1), 439‑446. https://doi.org/10.32614/RJ-2018-009\n\n\nPebesma, E. et Bivand, R. (2005). Classes and methods for spatial data in R. R News, 5(2), 9‑13. https://CRAN.R-project.org/doc/Rnews/\n\n\nPebesma, E. et Bivand, R. (2023). Spatial Data Science: With applications in R (p. 352). Chapman and Hall/CRC. https://r-spatial.org/book/\n\n\nPROJ contributors. (2021). PROJ coordinate transformation software library. Open Source Geospatial Foundation. https://proj.org/\n\n\nWickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L. D., François, R., Grolemund, G., Hayes, A., Henry, L., Hester, J., Kuhn, M., Pedersen, T. L., Miller, E., Bache, S. M., Müller, K., Ooms, J., Robinson, D., Seidel, D. P., Spinu, V., Takahashi, K., et al.Yutani, H. (2019). Welcome to the tidyverse. Journal of Open Source Software, 4(43), 1686. https://doi.org/10.21105/joss.01686"
  },
  {
    "objectID": "02_import_sf.html#import",
    "href": "02_import_sf.html#import",
    "title": "2  Import et export",
    "section": "2.1 Import",
    "text": "2.1 Import\nLes lignes suivantes importent la couche des communes du département du Lot situé dans le fichier geopackage lot.gpkg.\n\nlibrary(sf)\n\n#&gt; Linking to GEOS 3.11.1, GDAL 3.6.2, PROJ 9.1.1; sf_use_s2() is TRUE\n\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\")\n\n#&gt; Reading layer `communes' from data source \n#&gt;   `/home/tim/Documents/prj/geomatique_avec_r/data/lot.gpkg' using driver `GPKG'\n#&gt; Simple feature collection with 313 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n\n\n\n\n\n\n\n\nGeopackage\n\n\n\nLe format geopackage permet de stocker plusieurs couches dans un même fichier.\nLa fonction st_layers() permet d’avoir un aperçu des couches présentes dans un fichier geopackage.\n\nst_layers(\"data/lot.gpkg\")\n\n#&gt; Driver: GPKG \n#&gt; Available layers:\n#&gt;     layer_name geometry_type features fields              crs_name\n#&gt; 1     communes Multi Polygon      313     12 RGF93 v1 / Lambert-93\n#&gt; 2 departements Multi Polygon       96      5 RGF93 v1 / Lambert-93\n#&gt; 3  restaurants         Point      694      2 RGF93 v1 / Lambert-93\n#&gt; 4   elevations         Point     5228      1 RGF93 v1 / Lambert-93\n#&gt; 5       routes   Line String     1054      2 RGF93 v1 / Lambert-93"
  },
  {
    "objectID": "02_import_sf.html#export",
    "href": "02_import_sf.html#export",
    "title": "2  Import et export",
    "section": "2.2 Export",
    "text": "2.2 Export\nLes lignes suivantes exportent l’objet com dans la couche communes du geopackage com.gpkg dans le dossier data.\n\nst_write(obj = com, dsn = \"data/com.gpkg\", layer = \"communes\")\n\n#&gt; Writing layer `communes' to data source `data/com.gpkg' using driver `GPKG'\n#&gt; Writing 313 features with 12 fields and geometry type Multi Polygon."
  },
  {
    "objectID": "03_affichage_sf.html#aperçu-des-variables",
    "href": "03_affichage_sf.html#aperçu-des-variables",
    "title": "3  Exploration et affichage",
    "section": "3.1 Aperçu des variables",
    "text": "3.1 Aperçu des variables\nLes objets sf sont des data.frame.\nNous pouvons utiliser les fonctions head() ou summary().\n\nlibrary(sf)\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\nhead(com, n = 3)\n\n#&gt; Simple feature collection with 3 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 557759.2 ymin: 6371852 xmax: 607179 ymax: 6418606\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;   INSEE_COM  NOM_COM         STATUT POPULATION     AGR_H    AGR_F     IND_H\n#&gt; 1     46001    Albas Commune simple        522  4.978581 0.000000  4.936153\n#&gt; 2     46002   Albiac Commune simple         67  0.000000 9.589041  0.000000\n#&gt; 3     46003 Alvignac Commune simple        706 10.419682 0.000000 10.419682\n#&gt;      IND_F     BTP_H BTP_F     TER_H     TER_F                           geom\n#&gt; 1 0.000000  9.957527     0 44.917145 34.681799 MULTIPOLYGON (((559262 6371...\n#&gt; 2 0.000000  4.794521     0  4.794521  9.589041 MULTIPOLYGON (((605540.7 64...\n#&gt; 3 5.209841 10.419682     0 57.308249 78.147612 MULTIPOLYGON (((593707.7 64...\n\nsummary(com)\n\n#&gt;   INSEE_COM           NOM_COM             STATUT            POPULATION     \n#&gt;  Length:313         Length:313         Length:313         Min.   :   49.0  \n#&gt;  Class :character   Class :character   Class :character   1st Qu.:  172.0  \n#&gt;  Mode  :character   Mode  :character   Mode  :character   Median :  300.0  \n#&gt;                                                           Mean   :  555.7  \n#&gt;                                                           3rd Qu.:  529.0  \n#&gt;                                                           Max.   :19907.0  \n#&gt;      AGR_H            AGR_F            IND_H             IND_F        \n#&gt;  Min.   : 0.000   Min.   : 0.000   Min.   :  0.000   Min.   :  0.000  \n#&gt;  1st Qu.: 0.000   1st Qu.: 0.000   1st Qu.:  4.843   1st Qu.:  0.000  \n#&gt;  Median : 5.000   Median : 0.000   Median :  5.516   Median :  4.943  \n#&gt;  Mean   : 6.935   Mean   : 2.594   Mean   : 16.395   Mean   :  7.635  \n#&gt;  3rd Qu.:10.013   3rd Qu.: 5.000   3rd Qu.: 19.715   3rd Qu.:  9.905  \n#&gt;  Max.   :56.179   Max.   :24.641   Max.   :602.867   Max.   :184.016  \n#&gt;      BTP_H             BTP_F             TER_H             TER_F        \n#&gt;  Min.   :  0.000   Min.   : 0.0000   Min.   :   0.00   Min.   :   0.00  \n#&gt;  1st Qu.:  0.000   1st Qu.: 0.0000   1st Qu.:  10.00   1st Qu.:  15.15  \n#&gt;  Median :  5.000   Median : 0.0000   Median :  20.00   Median :  30.26  \n#&gt;  Mean   :  9.572   Mean   : 0.9723   Mean   :  42.17   Mean   :  60.77  \n#&gt;  3rd Qu.: 10.329   3rd Qu.: 0.0000   3rd Qu.:  44.69   3rd Qu.:  63.95  \n#&gt;  Max.   :203.122   Max.   :16.9238   Max.   :1778.87   Max.   :2397.18  \n#&gt;             geom    \n#&gt;  MULTIPOLYGON :313  \n#&gt;  epsg:2154    :  0  \n#&gt;  +proj=lcc ...:  0  \n#&gt;                     \n#&gt;                     \n#&gt; \n\n\n\n\n\n\n\n\nSupprimer la colonne de géométrie d’un objet sf\n\n\n\nPour transformer un objet sf en data.frame “pur” nous pouvons utiliser les fonctions st_set_geometry() ou st_drop_geometry().\n\ncom_df1 &lt;- st_set_geometry(com, NULL)\ncom_df2 &lt;- st_drop_geometry(com)\nidentical(com_df1, com_df2)\n\n#&gt; [1] TRUE\n\nhead(com_df1, n = 3)\n\n#&gt;   INSEE_COM  NOM_COM         STATUT POPULATION     AGR_H    AGR_F     IND_H\n#&gt; 1     46001    Albas Commune simple        522  4.978581 0.000000  4.936153\n#&gt; 2     46002   Albiac Commune simple         67  0.000000 9.589041  0.000000\n#&gt; 3     46003 Alvignac Commune simple        706 10.419682 0.000000 10.419682\n#&gt;      IND_F     BTP_H BTP_F     TER_H     TER_F\n#&gt; 1 0.000000  9.957527     0 44.917145 34.681799\n#&gt; 2 0.000000  4.794521     0  4.794521  9.589041\n#&gt; 3 5.209841 10.419682     0 57.308249 78.147612"
  },
  {
    "objectID": "03_affichage_sf.html#affichage",
    "href": "03_affichage_sf.html#affichage",
    "title": "3  Exploration et affichage",
    "section": "3.2 Affichage",
    "text": "3.2 Affichage\nAperçu des variables avec plot() :\n\nplot(com)\n\n#&gt; Warning: plotting the first 9 out of 12 attributes; use max.plot = 12 to plot\n#&gt; all\n\n\n\n\n\nAffichage d’une seule variable :\n\nplot(com[\"POPULATION\"])\n\n\n\n\nAffichage de la géométrie seule :\n\nplot(st_geometry(com), col = \"ivory4\", border = \"ivory\")\n\n\n\n\nIl est aussi possible d’utiliser le package mapsf (Giraud, 2022) pour afficher les objets sf\n\nlibrary(mapsf)\nmf_map(com, col = \"ivory4\", border = \"ivory\")\n\n\n\n\n\n\n\n\nGiraud, T. (2022). mapsf: Thematic Cartography. https://CRAN.R-project.org/package=mapsf"
  },
  {
    "objectID": "04_projection_sf.html#consulter-le-système-de-coordonnées-dun-objet",
    "href": "04_projection_sf.html#consulter-le-système-de-coordonnées-dun-objet",
    "title": "4  Les systèmes de coordonnées",
    "section": "4.1 Consulter le système de coordonnées d’un objet",
    "text": "4.1 Consulter le système de coordonnées d’un objet\nLa fonction st_crs() permet de consulter le système de coordonnées utilisé par un objet sf.\n\nlibrary(sf) \nst_crs(com)\n\n#&gt; Coordinate Reference System:\n#&gt;   User input: RGF93 v1 / Lambert-93 \n#&gt;   wkt:\n#&gt; PROJCRS[\"RGF93 v1 / Lambert-93\",\n#&gt;     BASEGEOGCRS[\"RGF93 v1\",\n#&gt;         DATUM[\"Reseau Geodesique Francais 1993 v1\",\n#&gt;             ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n#&gt;                 LENGTHUNIT[\"metre\",1]]],\n#&gt;         PRIMEM[\"Greenwich\",0,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#&gt;         ID[\"EPSG\",4171]],\n#&gt;     CONVERSION[\"Lambert-93\",\n#&gt;         METHOD[\"Lambert Conic Conformal (2SP)\",\n#&gt;             ID[\"EPSG\",9802]],\n#&gt;         PARAMETER[\"Latitude of false origin\",46.5,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8821]],\n#&gt;         PARAMETER[\"Longitude of false origin\",3,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8822]],\n#&gt;         PARAMETER[\"Latitude of 1st standard parallel\",49,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8823]],\n#&gt;         PARAMETER[\"Latitude of 2nd standard parallel\",44,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8824]],\n#&gt;         PARAMETER[\"Easting at false origin\",700000,\n#&gt;             LENGTHUNIT[\"metre\",1],\n#&gt;             ID[\"EPSG\",8826]],\n#&gt;         PARAMETER[\"Northing at false origin\",6600000,\n#&gt;             LENGTHUNIT[\"metre\",1],\n#&gt;             ID[\"EPSG\",8827]]],\n#&gt;     CS[Cartesian,2],\n#&gt;         AXIS[\"easting (X)\",east,\n#&gt;             ORDER[1],\n#&gt;             LENGTHUNIT[\"metre\",1]],\n#&gt;         AXIS[\"northing (Y)\",north,\n#&gt;             ORDER[2],\n#&gt;             LENGTHUNIT[\"metre\",1]],\n#&gt;     USAGE[\n#&gt;         SCOPE[\"Engineering survey, topographic mapping.\"],\n#&gt;         AREA[\"France - onshore and offshore, mainland and Corsica (France métropolitaine including Corsica).\"],\n#&gt;         BBOX[41.15,-9.86,51.56,10.38]],\n#&gt;     ID[\"EPSG\",2154]]"
  },
  {
    "objectID": "04_projection_sf.html#modifier-le-système-de-coordonnées-dun-objet",
    "href": "04_projection_sf.html#modifier-le-système-de-coordonnées-dun-objet",
    "title": "4  Les systèmes de coordonnées",
    "section": "4.2 Modifier le système de coordonnées d’un objet",
    "text": "4.2 Modifier le système de coordonnées d’un objet\nLa fonction st_transform() permet de changer le système de coordonnées d’un objet sf, de le reprojeter.\n\nmf_map(com, expandBB = c(0, .12, 0, 0))\nmf_graticule(x = com)\nmf_title(\"RGF93 / Lambert-93\")\ncom_reproj &lt;- st_transform(com, \"EPSG:3035\")\nmf_map(com_reproj, expandBB = c(0, .12, .0, 0))\nmf_graticule(x = com_reproj)\nmf_title(\"ETRS89-extended / LAEA Europe\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLe site Spatial Reference met à disposition les références de très nombreux systèmes coordonnées.\nSi l’on souhaite projeter un objet spatial, intialement en coordonnées géographiques (lon/lat), le package crsuggest (Walker, 2022) propose des projections adaptées à l’emprise de l’objet.\n\n\n\n\n\n\n\nWalker, K. (2022). crsuggest: Obtain Suggested Coordinate Reference System Information for Spatial Data. https://CRAN.R-project.org/package=crsuggest"
  },
  {
    "objectID": "05_selection_attrib_sf.html",
    "href": "05_selection_attrib_sf.html",
    "title": "5  Sélection par attributs",
    "section": "",
    "text": "Les objets sf sont des data.frame, on peut donc sélectionner leur lignes et leur colonnes de la même manière que les data.frame.\n\n# sélection de lignes\ncom[1:2, ]\n\n#&gt; Simple feature collection with 2 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 557759.2 ymin: 6371852 xmax: 607179 ymax: 6410204\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;   INSEE_COM NOM_COM         STATUT POPULATION    AGR_H    AGR_F    IND_H IND_F\n#&gt; 1     46001   Albas Commune simple        522 4.978581 0.000000 4.936153     0\n#&gt; 2     46002  Albiac Commune simple         67 0.000000 9.589041 0.000000     0\n#&gt;      BTP_H BTP_F     TER_H     TER_F                           geom\n#&gt; 1 9.957527     0 44.917145 34.681799 MULTIPOLYGON (((559262 6371...\n#&gt; 2 4.794521     0  4.794521  9.589041 MULTIPOLYGON (((605540.7 64...\n\ncom[com$NOM_COM == \"Gramat\", ]\n\n#&gt; Simple feature collection with 1 feature and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 593605.6 ymin: 6402330 xmax: 602624.6 ymax: 6413784\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;     INSEE_COM NOM_COM         STATUT POPULATION    AGR_H    AGR_F    IND_H\n#&gt; 119     46128  Gramat Commune simple       3468 10.19868 15.29802 122.3842\n#&gt;        IND_F    BTP_H BTP_F    TER_H    TER_F                           geom\n#&gt; 119 107.0862 56.09275     0 260.0664 304.1941 MULTIPOLYGON (((594713.1 64...\n\n# sélection de colonnes\ncom[com$NOM_COM == \"Gramat\", 1:4]\n\n#&gt; Simple feature collection with 1 feature and 4 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 593605.6 ymin: 6402330 xmax: 602624.6 ymax: 6413784\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;     INSEE_COM NOM_COM         STATUT POPULATION                           geom\n#&gt; 119     46128  Gramat Commune simple       3468 MULTIPOLYGON (((594713.1 64...\n\ncom[, \"POPULATION\"]\n\n#&gt; Simple feature collection with 313 features and 1 field\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt; First 10 features:\n#&gt;    POPULATION                           geom\n#&gt; 1         522 MULTIPOLYGON (((559262 6371...\n#&gt; 2          67 MULTIPOLYGON (((605540.7 64...\n#&gt; 3         706 MULTIPOLYGON (((593707.7 64...\n#&gt; 4         219 MULTIPOLYGON (((613211.3 64...\n#&gt; 5         329 MULTIPOLYGON (((556744.9 63...\n#&gt; 6         377 MULTIPOLYGON (((576667.2 64...\n#&gt; 7         988 MULTIPOLYGON (((581404 6370...\n#&gt; 8         203 MULTIPOLYGON (((558216 6389...\n#&gt; 9         642 MULTIPOLYGON (((612729.6 63...\n#&gt; 10        367 MULTIPOLYGON (((581404 6370..."
  },
  {
    "objectID": "06_selection_jointure_spatiale_sf.html#sélection-spatiale",
    "href": "06_selection_jointure_spatiale_sf.html#sélection-spatiale",
    "title": "6  Sélection et jointure spatiales",
    "section": "6.1 Sélection spatiale",
    "text": "6.1 Sélection spatiale\nLa fonction st_filter() permet d’effectuer des sélections spatiales. L’argument .predicate permet de choisir sur quel critère se fait la selection en utilisant l’une des fonctions de “predicat géométrique” (par exemple st_intersects(), st_within(), st_crosses()…).\nNous allons ici sélectionner les routes qui intersectent la commune de Gramat\n\nroute &lt;- st_read(\"data/lot.gpkg\", layer = \"routes\", quiet = TRUE)\ngramat &lt;-  com[com$NOM_COM == \"Gramat\", ]\nroute_gramat &lt;-  st_filter(x = route, y = gramat,\n                           .predicate = st_intersects)\nmf_map(gramat, col = \"lightblue\")\nmf_map(route, add = TRUE)\nmf_map(route_gramat, col = \"tomato\", lwd = 2, add = TRUE)"
  },
  {
    "objectID": "06_selection_jointure_spatiale_sf.html#jointure-spatiale",
    "href": "06_selection_jointure_spatiale_sf.html#jointure-spatiale",
    "title": "6  Sélection et jointure spatiales",
    "section": "6.2 Jointure spatiale",
    "text": "6.2 Jointure spatiale\nLa fonction st_join() permet de réaliser des jointures spatiales. Cette fois-ci c’est l’argument join qui utilise une fonction de prédicat géométrique.\n\nroute_gramat &lt;-  st_join(x = route,\n                         y = com[, c(\"INSEE_COM\",\"NOM_COM\")],\n                         join = st_intersects,\n                         left = FALSE)\nroute_gramat\n\n#&gt; Simple feature collection with 1247 features and 4 fields\n#&gt; Geometry type: LINESTRING\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 587147.6 ymin: 6394844 xmax: 608194.7 ymax: 6420006\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt; First 10 features:\n#&gt;     ID      CLASS_ADM INSEE_COM        NOM_COM                           geom\n#&gt; 1    1 Départementale     46240     Rocamadour LINESTRING (590557.5 641181...\n#&gt; 2    2 Départementale     46240     Rocamadour LINESTRING (593733.2 641429...\n#&gt; 3    3 Départementale     46240     Rocamadour LINESTRING (590665 6412381,...\n#&gt; 4    4 Départementale     46128         Gramat LINESTRING (598940.9 640909...\n#&gt; 5    5 Départementale     46104   Flaujac-Gare LINESTRING (603201.9 640181...\n#&gt; 6    6     Sans objet     46235        Reilhac LINESTRING (598162.3 640108...\n#&gt; 7    7 Départementale     46090        Durbans LINESTRING (598887.3 639763...\n#&gt; 7.1  7 Départementale     46138 Cœur de Causse LINESTRING (598887.3 639763...\n#&gt; 7.2  7 Départementale     46233        Quissac LINESTRING (598887.3 639763...\n#&gt; 8    8 Départementale     46090        Durbans LINESTRING (601184.3 639697..."
  },
  {
    "objectID": "07_operation_geom_sf.html#extraire-des-centroides",
    "href": "07_operation_geom_sf.html#extraire-des-centroides",
    "title": "7  Opérations sur les géométries",
    "section": "7.1 Extraire des centroides",
    "text": "7.1 Extraire des centroides\n\ncom_c &lt;- st_centroid(com)\n\n#&gt; Warning: st_centroid assumes attributes are constant over geometries\n\nmf_map(com)\nmf_map(com_c, add = TRUE, cex = 1.2, col = \"red\", pch = 20)"
  },
  {
    "objectID": "07_operation_geom_sf.html#agréger-des-polygones",
    "href": "07_operation_geom_sf.html#agréger-des-polygones",
    "title": "7  Opérations sur les géométries",
    "section": "7.2 Agréger des polygones",
    "text": "7.2 Agréger des polygones\n\ndep_46 &lt;- st_union(com)\nmf_map(com, col = \"lightblue\")\nmf_map(dep_46, col = NA, border = \"red\", lwd = 2, add = TRUE)"
  },
  {
    "objectID": "07_operation_geom_sf.html#agréger-des-polygones-en-fonction-dune-variable",
    "href": "07_operation_geom_sf.html#agréger-des-polygones-en-fonction-dune-variable",
    "title": "7  Opérations sur les géométries",
    "section": "7.3 Agréger des polygones en fonction d’une variable",
    "text": "7.3 Agréger des polygones en fonction d’une variable\n\nAvec dplyr\n\n\nlibrary(dplyr)\n\n#&gt; \n#&gt; Attaching package: 'dplyr'\n\n\n#&gt; The following objects are masked from 'package:stats':\n#&gt; \n#&gt;     filter, lag\n\n\n#&gt; The following objects are masked from 'package:base':\n#&gt; \n#&gt;     intersect, setdiff, setequal, union\n\ncom_u &lt;- com |&gt;\n  group_by(STATUT) |&gt;\n  summarise(POPULATION = sum(POPULATION))\n\n\nSans dplyr\n\n\ni &lt;- com$STATUT \ncom_u &lt;- st_sf(\n  STATUT     = tapply(X = i               , INDEX = i, FUN = head, 1),\n  POPULATION = tapply(X = com$POPULATION  , INDEX = i, FUN = sum), \n  geometry   = tapply(X = st_geometry(com), INDEX = i, FUN = st_union), \n  crs        = st_crs(com)\n)"
  },
  {
    "objectID": "07_operation_geom_sf.html#construire-une-zone-tampon",
    "href": "07_operation_geom_sf.html#construire-une-zone-tampon",
    "title": "7  Opérations sur les géométries",
    "section": "7.4 Construire une zone tampon",
    "text": "7.4 Construire une zone tampon\n\ngramat &lt;- com[com$NOM_COM == \"Gramat\", ]\ngramat_b &lt;- st_buffer(x = gramat, dist = 5000)\nmf_map(gramat_b, col = \"lightblue\", lwd=2, border = \"red\")\nmf_map(gramat, add = TRUE, lwd = 2)"
  },
  {
    "objectID": "07_operation_geom_sf.html#réaliser-une-intersection",
    "href": "07_operation_geom_sf.html#réaliser-une-intersection",
    "title": "7  Opérations sur les géométries",
    "section": "7.5 Réaliser une intersection",
    "text": "7.5 Réaliser une intersection\nEn utilisant la fonction st_intersection() on va découper une couche par une autre.\n\n# création d'une zone tampon autour du centroid de la commune de Gramat\n# en utilisant le pipe\nzone &lt;- st_geometry(gramat) |&gt;\n  st_centroid() |&gt;\n  st_buffer(10000)\nmf_map(com)\nmf_map(zone, border = \"red\", col = NA, lwd = 2, add = TRUE)\n\n\n\ncom_z &lt;- st_intersection(x = com, y = zone)\n\n#&gt; Warning: attribute variables are assumed to be spatially constant throughout\n#&gt; all geometries\n\nmf_map(com)\nmf_map(com_z, col = \"red\", border = \"green\", add = TRUE)\n\n\n\nmf_map(com_z)"
  },
  {
    "objectID": "07_operation_geom_sf.html#créer-une-grille-régulière",
    "href": "07_operation_geom_sf.html#créer-une-grille-régulière",
    "title": "7  Opérations sur les géométries",
    "section": "7.6 Créer une grille régulière",
    "text": "7.6 Créer une grille régulière\nLa fonction st_make_grid() permet de créer une grille régulière. La fonction produit un objet sfc, il faut ensuite utiliser la fonction st_sf() pour transformer cet objet sfc en objet sf. Lors de cette transformation nous rajoutons ici une colonne d’identifiants uniques.\n\ngrid &lt;- st_make_grid(x = com, cellsize = 5000)\ngrid &lt;- st_sf(ID = 1:length(grid), geom = grid)\nmf_map(grid, col = \"grey\", border = \"white\")\nmf_map(com, col = NA, border = \"grey50\", add = TRUE)"
  },
  {
    "objectID": "07_operation_geom_sf.html#compter-des-points-dans-un-polygone",
    "href": "07_operation_geom_sf.html#compter-des-points-dans-un-polygone",
    "title": "7  Opérations sur les géométries",
    "section": "7.7 Compter des points dans un polygone",
    "text": "7.7 Compter des points dans un polygone\nSélection des carreaux de la grille qui intersectent le département avec st_filter().\n\ngrid &lt;- st_filter(grid, dep_46, .predicate = st_intersects)\nrestaurant &lt;- st_read(\"data/lot.gpkg\", layer = \"restaurants\", quiet = TRUE)\nmf_map(grid, col = \"grey\", border = \"white\")\nmf_map(restaurant, pch = 20, col = \"red\", cex = .5, add = TRUE)\n\n\n\n\nNous utilisons ensuite la fonction st_intersects(..., sparse = TRUE) qui nous permettra d’avoir pour chaque élément de l’objet grid la liste des éléments (via leurs indexes) de l’objet restaurant qui se trouvent à l’intérieur.\n\ninter &lt;- st_intersects(grid, restaurant, sparse = TRUE)\nlength(inter) == nrow(grid)\n\n#&gt; [1] TRUE\n\n\nPour compter le nombre de restaurants il suffit donc de reporter la longueur de chacun des éléments de cette liste.\n\ngrid$nb_restaurant &lt;- lengths(inter)\nmf_map(grid)\nmf_map(grid, var = \"nb_restaurant\", type = \"prop\")\n\n#&gt; 94 '0' values are not plotted on the map."
  },
  {
    "objectID": "07_operation_geom_sf.html#aggréger-les-valeurs-de-points-dans-des-polygones",
    "href": "07_operation_geom_sf.html#aggréger-les-valeurs-de-points-dans-des-polygones",
    "title": "7  Opérations sur les géométries",
    "section": "7.8 Aggréger les valeurs de points dans des polygones",
    "text": "7.8 Aggréger les valeurs de points dans des polygones\nIci nous voulons résumer l’information contenue dans une couche de points dans des polygones. Nous voulons connaître l’altitude minimale et maximale de chaque communes.\nNous pouvons commencer par importer une couche de points d’altitude (la couche elevations du fichier lot.gpkg)\n\nelev &lt;- st_read(\"data/lot.gpkg\", \"elevations\", quiet = TRUE)\n\nmf_map(elev, \"elevation\", \"choro\", \n       breaks = c(80, seq(100, 700, by = 100), 742),\n       pal = hcl.colors(8, \"Terrain2\"), \n       pch = 21, leg_pos = \"topleft\", cex = .75)\n\n\n\n\nL’objectif est d’agréger les valeurs de ces points (les altitudes contenues dans le champ elevation) dans les communes du Lot.\nEn utilisant la fonction st_join() nous pouvons récupérer les attributs des communes dans lesquelles se trouvent les points.\n\ninter &lt;- st_join(x = elev, y = com[, \"INSEE_COM\"])\ninter\n\n#&gt; Simple feature collection with 5228 features and 2 fields\n#&gt; Geometry type: POINT\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 540333.3 ymin: 6347372 xmax: 637333.3 ymax: 6439372\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt; First 10 features:\n#&gt;    elevation INSEE_COM                     geom\n#&gt; 1   308.8546     46083 POINT (584333.3 6439372)\n#&gt; 2   304.6855     46083 POINT (582333.3 6438372)\n#&gt; 3   290.6638     46083 POINT (583333.3 6438372)\n#&gt; 4   295.0353     46083 POINT (584333.3 6438372)\n#&gt; 5   297.6773     46083 POINT (587333.3 6438372)\n#&gt; 6   257.7393     46083 POINT (588333.3 6438372)\n#&gt; 7   310.1883     46083 POINT (580333.3 6437372)\n#&gt; 8   305.0571     46083 POINT (581333.3 6437372)\n#&gt; 9   298.5876     46083 POINT (582333.3 6437372)\n#&gt; 10  287.6990     46083 POINT (583333.3 6437372)\n\n\nNous pouvons ensuite utiliser la fonction aggregate() pour agréger les altitudes par communes, d’abord l’altitude minimal, puis l’altitude maximale.\n\nalti_min &lt;- aggregate(x = list(alt_min = inter$elevation),\n                      by = list(INSEE_COM = inter$INSEE_COM),\n                      FUN = \"min\")\nalti_max &lt;- aggregate(x = list(alt_max = inter$elevation),\n                      by = list(INSEE_COM = inter$INSEE_COM),\n                      FUN = \"max\")\nhead(alti_max, n = 3)\n\n#&gt;   INSEE_COM  alt_max\n#&gt; 1     46001 302.4913\n#&gt; 2     46002 393.9218\n#&gt; 3     46003 376.6632\n\n\nOn peut ensuite combiner ces résultat à la couche des communes (avec la fonction merge()).\n\ncom &lt;- merge(com, alti_min, by = \"INSEE_COM\", all.x = TRUE)\ncom &lt;- merge(com, alti_max, by = \"INSEE_COM\", all.x = TRUE)\nhead(com, n = 3)\n\n#&gt; Simple feature collection with 3 features and 14 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 557759.2 ymin: 6371852 xmax: 607179 ymax: 6418606\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;   INSEE_COM  NOM_COM         STATUT POPULATION     AGR_H    AGR_F     IND_H\n#&gt; 1     46001    Albas Commune simple        522  4.978581 0.000000  4.936153\n#&gt; 2     46002   Albiac Commune simple         67  0.000000 9.589041  0.000000\n#&gt; 3     46003 Alvignac Commune simple        706 10.419682 0.000000 10.419682\n#&gt;      IND_F     BTP_H BTP_F     TER_H     TER_F  alt_min  alt_max\n#&gt; 1 0.000000  9.957527     0 44.917145 34.681799 109.5772 302.4913\n#&gt; 2 0.000000  4.794521     0  4.794521  9.589041 363.4579 393.9218\n#&gt; 3 5.209841 10.419682     0 57.308249 78.147612 258.8378 376.6632\n#&gt;                         geometry\n#&gt; 1 MULTIPOLYGON (((559262 6371...\n#&gt; 2 MULTIPOLYGON (((605540.7 64...\n#&gt; 3 MULTIPOLYGON (((593707.7 64...\n\n\n\nbks &lt;- c(80, seq(100, 700, by = 100), 742)\ncols &lt;- hcl.colors(8, \"Terrain2\")\nmf_map(com, \"alt_min\", \"choro\", breaks = bks, pal = cols)\nmf_map(com, \"alt_max\", \"choro\", breaks = bks, pal = cols)"
  },
  {
    "objectID": "08_mesures_sf.html#créer-une-matrice-de-distances",
    "href": "08_mesures_sf.html#créer-une-matrice-de-distances",
    "title": "8  Mesures",
    "section": "8.1 Créer une matrice de distances",
    "text": "8.1 Créer une matrice de distances\nSi le système de projection du jeu de données est renseigné les distances sont exprimées dans l’unité de mesure de la projection (en mètres le plus souvent).\n\nlibrary(sf)\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\ncom_c &lt;- st_centroid(com)\n\n#&gt; Warning: st_centroid assumes attributes are constant over geometries\n\nmat &lt;- st_distance(x = com_c, y = com_c)\nmat[1:5,1:5]\n\n#&gt; Units: [m]\n#&gt;           [,1]     [,2]     [,3]     [,4]      [,5]\n#&gt; [1,]     0.000 56784.77 54353.94 61166.42  3790.688\n#&gt; [2,] 56784.770     0.00 12454.29  7146.11 57288.103\n#&gt; [3,] 54353.942 12454.29     0.00 19388.52 54030.811\n#&gt; [4,] 61166.418  7146.11 19388.52     0.00 62016.141\n#&gt; [5,]  3790.688 57288.10 54030.81 62016.14     0.000"
  },
  {
    "objectID": "08_mesures_sf.html#calcul-de-superficies",
    "href": "08_mesures_sf.html#calcul-de-superficies",
    "title": "8  Mesures",
    "section": "8.2 Calcul de superficies",
    "text": "8.2 Calcul de superficies\nLa fonction st_area() permet de calculer des superficies.\n\nst_area(com[1:5, ])\n\n#&gt; Units: [m^2]\n#&gt; [1] 21721665  3813205 13024216  9993074  5540367"
  },
  {
    "objectID": "09_exercices_sf.html#exercice-1",
    "href": "09_exercices_sf.html#exercice-1",
    "title": "9  Exercices",
    "section": "9.1 Exercice 1",
    "text": "9.1 Exercice 1\nCalculer le nombre de restaurants par commune.\n\nQuelles communes ont plus de 10 restaurants et moins de 1000 habitants ?\nCréez une carte où vous afficherez toutes les communes en gris et les communes sélectionnées plus haut en rouge."
  },
  {
    "objectID": "09_exercices_sf.html#exercice-2",
    "href": "09_exercices_sf.html#exercice-2",
    "title": "9  Exercices",
    "section": "9.2 Exercice 2",
    "text": "9.2 Exercice 2\nMesurer la densité du réseau routier par commune.\n\nIntersecter les routes par les communes\nDécouper les routes par les communes. Chaque segment de route récupère l’identifiant de la commune dans laquelle il se trouve. st_intersection()\nCalculer la longueur des segments de route\nRajouter une colonne longueur qui contient la longueur de chacun des segments. st_length()\nCalculer la longueur totale de route par commune\nAggreger les segments de routes par commune pour obtenir des longueurs totales par commune. aggregate()\nJoindre les longueurs à la table des communes. merge()\nCalculer les superficies des communes. st_area()\nConvertir les unités des différentes mesures. units(...)&lt;-\"km^2\"\nCalculer les indicateurs\nLe premier est le rapport entre la longueur des routes et la population des communes.\nLe deuxième est le rapport entre la longueur des routes et la superficie des communes."
  },
  {
    "objectID": "10_georeferencement.html#géocodage-dadresse-avec-tidygeocoder",
    "href": "10_georeferencement.html#géocodage-dadresse-avec-tidygeocoder",
    "title": "10  Géocoder des adresses",
    "section": "10.1 Géocodage d’adresse avec tidygeocoder",
    "text": "10.1 Géocodage d’adresse avec tidygeocoder\nPlusieurs packages permettent de géocoder des adresses.  Le package tidygeocoder (Cambon et al., 2021) permet d’utiliser un grand nombre de services de géocodage en ligne.\n\nlibrary(tidygeocoder)\naddress_df &lt;- data.frame(\n  address = c(\"10 Emma Goldmanweg, 5032MN Tilburg, Netherlands\", \n              \"19 rue Michel Bakounine, 29600 Morlaix, France\")\n)\nplaces &lt;- geocode(.tbl = address_df, address = \"address\", quiet = TRUE)\nplaces\n\n#&gt; # A tibble: 2 × 3\n#&gt;   address                                           lat  long\n#&gt;   &lt;chr&gt;                                           &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 10 Emma Goldmanweg, 5032MN Tilburg, Netherlands  51.5  5.04\n#&gt; 2 19 rue Michel Bakounine, 29600 Morlaix, France   48.6 -3.82"
  },
  {
    "objectID": "10_georeferencement.html#transformer-des-données-longlat-en-objet-sf",
    "href": "10_georeferencement.html#transformer-des-données-longlat-en-objet-sf",
    "title": "10  Géocoder des adresses",
    "section": "10.2 Transformer des données long/lat en objet sf",
    "text": "10.2 Transformer des données long/lat en objet sf\nLa fonction st_as_sf() permet de créer un objet sf à partir d’un data.frame contenant des coordonnées géographiques.\nIci nous utilisons le data.frame places créé au point précédent :\n\nlibrary(sf)\nplace_sf &lt;- st_as_sf(places, \n                     coords = c(\"long\", \"lat\"), \n                     crs = 'EPSG:4326')\nplace_sf\n\n#&gt; Simple feature collection with 2 features and 1 field\n#&gt; Geometry type: POINT\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: -3.816434 ymin: 48.59041 xmax: 5.038699 ymax: 51.53649\n#&gt; Geodetic CRS:  WGS 84\n#&gt; # A tibble: 2 × 2\n#&gt;   address                                                     geometry\n#&gt; * &lt;chr&gt;                                                    &lt;POINT [°]&gt;\n#&gt; 1 10 Emma Goldmanweg, 5032MN Tilburg, Netherlands  (5.038699 51.53649)\n#&gt; 2 19 rue Michel Bakounine, 29600 Morlaix, France  (-3.816435 48.59041)\n\n\nPour créer un objet sf de type POINT à partir d’une paire de coordonnées, ici le point de longitude 0.5 et de latitude 45.5 en WGS84 (EPSG:4326), il faut créer le data.frame au préalable :\n\nlibrary(sf)\ndf_pt &lt;- data.frame(x = 0.5, y = 45.5)\nmon_point &lt;- st_as_sf(df_pt, coords = c(\"x\", \"y\"), crs = 'EPSG:4326')\nmon_point\n\n#&gt; Simple feature collection with 1 feature and 0 fields\n#&gt; Geometry type: POINT\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 0.5 ymin: 45.5 xmax: 0.5 ymax: 45.5\n#&gt; Geodetic CRS:  WGS 84\n#&gt;           geometry\n#&gt; 1 POINT (0.5 45.5)"
  },
  {
    "objectID": "10_georeferencement.html#affichage-sur-un-fond-openstreetmap",
    "href": "10_georeferencement.html#affichage-sur-un-fond-openstreetmap",
    "title": "10  Géocoder des adresses",
    "section": "10.3 Affichage sur un fond OpenStreetMap",
    "text": "10.3 Affichage sur un fond OpenStreetMap\nNous pouvons afficher cet objet sf sur un fond de carte OpenStreetMap avec le package maptiles (Giraud, 2023).\n\nlibrary(mapsf)\nlibrary(maptiles)\nosm &lt;- get_tiles(x = place_sf, zoom = 7)\nmf_raster(osm)\nmf_map(place_sf, pch = 4, cex = 2, \n       lwd = 2, col = \"red\", add = TRUE)\n\n\n\n\n\n\n\n\nCambon, J., Hernangómez, D., Belanger, C. et Possenriede, D. (2021). tidygeocoder: An R package for geocoding. Journal of Open Source Software, 6(65), 3544. https://doi.org/10.21105/joss.03544\n\n\nGiraud, T. (2023). maptiles: Download and Display Map Tiles. https://CRAN.R-project.org/package=maptiles"
  },
  {
    "objectID": "11_package_terra.html#présentation",
    "href": "11_package_terra.html#présentation",
    "title": "11  Le package terra",
    "section": "11.1 Présentation",
    "text": "11.1 Présentation\n L’objectif du package terra (Hijmans, 2023) est de proposer des méthodes de traitement et d’analyse de données rasrer. Ce package est très similaire au package raster; mais il propose plus de fonctionnalités, il est plus facile à utiliser et il est plus rapide.\nCe chapitre est largement inspiré de deux présentations (Madelin, 2021 ; Nowosad, 2021) réalisées dans le cadre de l’école thématique “Science de l’Information Géographique Reproductibles 2021” (SIGR2021).\n\n\n\n\n\n\nSite web du package terra :\n\n\n\nSpatial Data Science with R and “terra”"
  },
  {
    "objectID": "11_package_terra.html#format-des-objets-spatraster",
    "href": "11_package_terra.html#format-des-objets-spatraster",
    "title": "11  Le package terra",
    "section": "11.2 Format des objets SpatRaster",
    "text": "11.2 Format des objets SpatRaster\nLe package terra (Hijmans, 2023) permet de gérer des données vectorielles et raster. Pour manipuler ces données spatiales, terra les stockent dans des objets de type SpatVector et SpatRaster. Dans ce document, nous nous focalisons sur la manipulation de données raster (SpatRaster) à partir de fonctions proposées par ce package.\nUn objet SpatRaster représente des données matricielles, en une ou plusieurs couches (variables). Cet objet stocke également un certain nombre de paramètres fondamentaux qui le décrivent (nombre de colonnes, de lignes, étendue spatiale, système de référence des coordonnées…).\n\n\n\nRacine (2016)\n\n\n\n\n\n\nHijmans, R. J. (2023). terra: Spatial Data Analysis. https://CRAN.R-project.org/package=terra\n\n\nMadelin, M. (2021). Analyse d’images raster (et télédétection). https://mmadelin.github.io/sigr2021/SIGR2021_raster_MM.html.\n\n\nNowosad, J. (2021). Image processing and all things raster. https://nowosad.github.io/SIGR2021/workshop2/workshop2.html.\n\n\nRacine, E. B. (2016). The Visual Raster Cheat Sheet. https://rpubs.com/etiennebr/visualraster."
  },
  {
    "objectID": "12_import_terra.html#import",
    "href": "12_import_terra.html#import",
    "title": "12  Import et export",
    "section": "12.1 Import",
    "text": "12.1 Import\nLa fonction rast() permet de créer et/ou d’importer des données raster. Les lignes suivantes importent le fichier raster elevation.tif (Tagged Image File Format) au format d’objet SpatRaster.\n\nelev &lt;- rast(\"data/elevation.tif\") \nelev\n\n#&gt; class       : SpatRaster \n#&gt; dimensions  : 987, 1300, 1  (nrow, ncol, nlyr)\n#&gt; resolution  : 0.0002972796, 0.0002972796  (x, y)\n#&gt; extent      : 1.245749, 1.632213, 44.30927, 44.60269  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#&gt; source      : elevation.tif \n#&gt; name        : altitude \n#&gt; min value   :       91 \n#&gt; max value   :      421"
  },
  {
    "objectID": "12_import_terra.html#export",
    "href": "12_import_terra.html#export",
    "title": "12  Import et export",
    "section": "12.2 Export",
    "text": "12.2 Export\nLa fonction writeRaster() permet d’enregistrer un objet SpatRaster sur votre machine, dans le format de votre choix.\n\nwriteRaster(x = elev, filename = \"data/new_elevation_Lot.tif\")\n\n\n\n\n\nGDAL/OGR contributors. (2022). GDAL/OGR Geospatial Data Abstraction software Library. Open Source Geospatial Foundation. https://doi.org/10.5281/zenodo.5884351"
  },
  {
    "objectID": "13_affichage_terra.html",
    "href": "13_affichage_terra.html",
    "title": "13  Affichage",
    "section": "",
    "text": "La fonction plot() permet d’afficher un objet SpatRaster.\n\nlibrary(terra)\n\n#&gt; terra 1.7.55\n\nelev &lt;- rast(\"data/elevation.tif\") \nplot(elev)\n\n\n\n\nUn raster contient toujours des données numériques, mais il peut aussi bien s’agir de données quantitatives que de données qualitatives (catégorielles) codées numériquement (ex: type d’occupation du sol).\nPrécisez le type de données stockées avec l’argument type (type = \"continuous\" par défaut), pour les afficher correctement.\nImport et affichage d’un raster contenant des données catégorielles : CORINE Land Cover 2018 (type d’occupation du sol) avec une résolution de 100m :\n\n# Import des données CORINE Land Cover 2018 \n# Type d'occupation du sol, résolution de 100m\nclc &lt;- rast(\"data/clc_2018.tif\")\n\nCes données ont été récupérées sur le site de Copernicus, le programme européen de surveillance de la Terre qui collecte et met à disposition des données issues de ses propres satellites (Sentinelles) d’observation. Une extraction centrée sur la commune de Cahors a ensuite été réalisée.\n\nplot(clc, type=\"classes\")\n\n\n\n\nPour afficher les intitulés réels des types d’occupation du sol, ainsi que les couleurs officielles de la nomenclature CORINE Land Cover (consultables ici), vous pouvez procéder de la manière suivante.\n\nintitule_poste &lt;- c(\n  \"Tissu urbain continu\", \"Tissu urbain discontinu\",\n  \"Zones industrielles ou commerciales et installations publiques\",\n  \"Réseaux routier et ferroviaire et espaces associés\", \n  \"Aéroports\",\"Extraction de matériaux\", \n  \"Equipements sportifs et de loisirs\", \n  \"Terres arables hors périmètres d'irrigation\", \"Vignobles\", \n  \"Vergers et petits fruits\", \n  \"Prairies et autres surfaces toujours en herbe à usage agricole\", \n  \"Systèmes culturaux et parcellaires complexes\", \n  \"Surfaces essentiellement agricoles (interrompues par espaces nat.)\", \n  \"Forêts de feuillus\", \"Forêts de conifères\", \"Forêts mélangées\",\n  \"Pelouses et pâturages naturels\", \n  \"Landes et broussailles\", \"Végétation sclérophylle\", \n  \"Forêt et végétation arbustive en mutation\", \n  \"Cours et voies d'eau\", \"Plans d'eau\"\n)\ncouleur_off &lt;- c(\"#E6004D\", \"#FF0000\", \"#CC4DF2\", \"#CC0000\", \"#E6CCE6\", \"#A600CC\", \n                 \"#FFE6FF\", \"#FFFFA8\", \"#E68000\", \"#F2A64D\", \"#E6E64D\", \"#FFE64D\", \n                 \"#E6CC4D\", \"#80FF00\", \"#00A600\", \"#4DFF00\", \"#CCF24D\", \"#A6FF80\", \n                 \"#A6E64D\", \"#A6F200\", \"#00CCF2\", \"#80F2E6\")\nplot(clc, \n     type = \"classes\", \n     levels = intitule_poste,\n     col = couleur_off, \n     plg = list(cex = 0.7),\n     mar = c(3.1, 1.1, 1.1, 10)\n     )"
  },
  {
    "objectID": "14_modif_zone_terra.html#sec-proj",
    "href": "14_modif_zone_terra.html#sec-proj",
    "title": "14  Modifications de la zone d’étude",
    "section": "14.1 Projections",
    "text": "14.1 Projections\nPour modifier le système de projection d’un raster, utilisez la fonction project(). Il est alors nécessaire de fournir un modèle et d’indiquer la méthode d’estimation des nouvelles valeurs des cellules.\nLe modèle est un nouveau raster sur lequel aligner/projeter les données. Pour construire un model vous pouvez d’abord faire project(x, crs) et ensuite manipuler la sortie pour obtenir le modèle que vous voulez. Par exemple, dans la mesure du possible, utilisez des nombres entiers pour l’étendue et la résolution. Vous pouvez utiliser des commandes telles que dim(z) = c(180, 360) ou res(z) &lt;- 100000. (voir ?project)\nQuatre méthodes d’estimation sont disponibles :\n\nnear : plus proche voisin. Méthode rapide et par défaut pour les données qualitatives;\n\nbilinear : interpolation bilinéaire. Méthode par défaut pour les données quantitatives;\n\ncubic : interpolation cubique;\n\ncubicspline : interpolation cubique spline.\n\n\nlibrary(terra)\n\n#&gt; terra 1.7.55\n\nelev_raw &lt;- rast(\"data/elevation.tif\") \nclc_raw &lt;- rast(\"data/clc_2018.tif\")\n# Création d'un modele de raster en 2154\nmodel_proj &lt;- project(x = elev_raw, y =  \"EPSG:2154\")\n# ajustement de la résolution du modèle\nres(model_proj) &lt;- 100\n# projection dans le modèle\nelev &lt;- project(x = elev_raw, y = model_proj, method = \"bilinear\")\nclc &lt;- project(x = clc_raw, y = model_proj, method = \"near\")\nplot(elev, main = \"Altitudes - RGF93 v1 / Lambert-93\" )\nplot(clc, type = \"classes\",  main = \"CLC - RGF93 v1 / Lambert-93\")\n\n\n\n\n\n\n\n\n\n\n\nSauvegarde des rasters reprojetés :\n\nwriteRaster(elev, filename = \"data/elev.tif\")\nwriteRaster(clc, filename = \"data/clc.tif\")"
  },
  {
    "objectID": "14_modif_zone_terra.html#sec-crop",
    "href": "14_modif_zone_terra.html#sec-crop",
    "title": "14  Modifications de la zone d’étude",
    "section": "14.2 Crop",
    "text": "14.2 Crop\nLe découpage d’un raster en fonction de l’étendue d’un autre objet, SpatVector ou SpatRaster, est réalisable avec la fonction crop().\n\n\n\n\n\n\nRacine (2016)\n\n\n\n\n\n\n\n\nImport de données vectorielles (découpages communaux) avec la fonction vect. Ces données seront stockées dans un objet SpatVector.\n\ncommune &lt;- vect(\"data/lot.gpkg\", layer=\"communes\")\n\nExtraction des limites communales de Cahors (code INSEE : 46042).\n\ncahors &lt;- subset(commune, commune$INSEE_COM == \"46042\") \n\nUtilisation de la fonction crop(). Les deux couches de données doivent être dans la même projection.\n\ncrop_cahors &lt;- crop(elev, cahors)\nplot(crop_cahors)\nplot(cahors, add = TRUE)"
  },
  {
    "objectID": "14_modif_zone_terra.html#mask",
    "href": "14_modif_zone_terra.html#mask",
    "title": "14  Modifications de la zone d’étude",
    "section": "14.3 Mask",
    "text": "14.3 Mask\nPour afficher uniquement les valeurs d’un raster contenu dans un polygone, utilisez la fonction mask().\nCréation d’un masque sur le raster crop_cahors en fonction des limites communales (polygone) de cahors.\n\nmask_cahors &lt;- mask(crop_cahors, cahors)\nplot(mask_cahors)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMask vs. Crop\n\n\n\nMasquer un raster (mask) signifie remplacer les valeurs de pixels en dehors d’une zone d’intérêt en NA. Les dimensions du raster ne sont pas modifiées.\nRecadrer un raster (crop) signifie supprimer les lignes et/ou les colonnes qui se trouvent en dehors d’une zone d’intéret. Les dimensions du raster sont modifiées."
  },
  {
    "objectID": "14_modif_zone_terra.html#agrégation-désagrégation",
    "href": "14_modif_zone_terra.html#agrégation-désagrégation",
    "title": "14  Modifications de la zone d’étude",
    "section": "14.4 Agrégation & désagrégation",
    "text": "14.4 Agrégation & désagrégation\n\n\n\n \n\n\n\n\n\n \n\n\n\n\n\n\n\nRacine (2016)\n\n\n\n\n\n\n\n\nLe ré-échantillonnage d’un raster dans une résolution différente se fait en deux étapes.\n\nAfficher la résolution d’un raster avec la fonction res().\n\n\n# Taille des cellules ?\nres(elev) \n\n#&gt; [1] 100 100\n\n\n\nCréer une grille de même étendue, puis en diminuer la résolution spatiale (plus grosses cellules).\n\n\nelev_lower_model  &lt;- elev\n# Tailles des cellules = 1000 mètres\nres(elev_lower_model) &lt;- 1000\n# res(elev_lower_model) &lt;- 10\nelev_lower_model\n\n#&gt; class       : SpatRaster \n#&gt; dimensions  : 33, 31, 1  (nrow, ncol, nlyr)\n#&gt; resolution  : 1000, 1000  (x, y)\n#&gt; extent      : 560073.1, 591073.1, 6357644, 6390644  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : RGF93 v1 / Lambert-93 (EPSG:2154)\n\n\n\nLa fonction resample() permet de ré-échantillonner les valeurs de départ dans la nouvelle résolution spatiale. Plusieurs méthodes de ré-échantillonnage sont disponibles (voir Section 14.1).\n\n\nelev_lower &lt;- resample(x = elev,\n                       y = elev_lower_model, \n                       method = \"bilinear\") \nplot(elev_lower, \n     main = \"Taille des cellules = 1000m\\nMéthode de ré-échantillonnage bilinéaire\")"
  },
  {
    "objectID": "14_modif_zone_terra.html#fusion-de-raster",
    "href": "14_modif_zone_terra.html#fusion-de-raster",
    "title": "14  Modifications de la zone d’étude",
    "section": "14.5 Fusion de raster",
    "text": "14.5 Fusion de raster\nFusionner plusieurs objets SpatRaster en un seul avec merge() ou mosaic().\n\n\n\nSite web ESRI\n\n\nAprès un découpage du raster d’élévation par la limite communale de Cahors (voir Section 14.2), nous réalisons la même chose pour la commune limitrophe de Bellefont-La Rauze.\n\n# Extraction des limites communales de Bellefont-La Rauze\nbellefont &lt;- subset(commune, commune$INSEE_COM == \"46156\") \n# Découpage du raster d'élévation en fonction des limites communales\ncrop_bellefont &lt;- crop(elev, bellefont)\n\nLes rasters d’élévation crop_cahors et crop_bellefont se chevauchent spatialement :\n\nplot(crop_cahors, main = \"Crop Cahors\")\nplot(cahors, add = TRUE)\nplot(bellefont, add = TRUE)\nplot(crop_bellefont, main = \"Crop Bellefont-La Rauze\")\nplot(bellefont, add = TRUE)\nplot(cahors, add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\nLa différence entre les fonctions merge() ou mosaic() concerne les valeurs des cellules qui se superposent. La fonction mosaic() calcule la valeur moyenne tandis que merge() conserve la valeur du premier objet SpatRaster appelé dans la fonction.\n\n# Dans cet exemple, merge() et mosaic() donnent le même résultat\nmerge_raster &lt;- merge(crop_cahors, crop_bellefont)\nmosaic_raster &lt;- mosaic(crop_cahors, crop_bellefont)\nplot(merge_raster)\nplot(bellefont, add = TRUE)\nplot(cahors, add = TRUE)"
  },
  {
    "objectID": "14_modif_zone_terra.html#segregate",
    "href": "14_modif_zone_terra.html#segregate",
    "title": "14  Modifications de la zone d’étude",
    "section": "14.6 Segregate",
    "text": "14.6 Segregate\nDécomposer un raster par valeur (ou modalité) en différentes couches matricielles avec la fonction segregate().\n\n# Création d'une couche matricielle par modalité\nclc_by_class &lt;- segregate(clc, keep = TRUE, other = NA)\nplot(clc_by_class)\n\n\n\n\n\n\n\n\nRacine, E. B. (2016). The Visual Raster Cheat Sheet. https://rpubs.com/etiennebr/visualraster."
  },
  {
    "objectID": "15_algebre_spatial_terra.html#opérations-locales",
    "href": "15_algebre_spatial_terra.html#opérations-locales",
    "title": "15  Algèbre spatial",
    "section": "15.1 Opérations locales",
    "text": "15.1 Opérations locales\n\n\n\nMennis (2015)\n\n\nLes opérations locales concernent les calculs réalisés indépendamment sur une cellule, à partir d’une ou plusieurs couches (matrices).\n\n15.1.1 Remplacement de valeur\n\n# Remplace les valeurs -9999 par NA\nelev[elev[[1]]== -9999] &lt;- NA\n# Remplace les valeurs &lt; 1500 par NA\nelev[elev &lt; 1500]  &lt;- NA\n# Remplace les valeurs NA par 0\nelev[is.na(elev )] &lt;- 0\n\n\n\n15.1.2 Opération sur chaque cellule\n\n# Ajout de 1000 à la valeur de chaque cellule\nelev_1000 &lt;-  elev + 1000\n# Suppression de l'altitude médiane à la valeur de chaque cellule\nelev_med &lt;-  elev - global(x = elev, fun = median, na.rm = TRUE)[[1]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n15.1.3 Reclassification\nLa reclassification des valeurs d’un raster peut aussi bien être utilisée pour discrétiser des données quantitatives que pour catégoriser des modalités qualitatives.\nCela permet par exemple de répartir les 44 postes de la nomenclature CLC selon les 5 grands types d’occupation du territoire : territoires artificialisés, agricoles, forêts et milieux semi-naturels, zones humides et surfaces en eau. Pour cela, il est d’abord nécessaire de construire la table (matrice) de correspondance.\n\nreclassif &lt;- matrix(c(100, 199, 1,\n                      200, 299, 2,\n                      300, 399, 3,\n                      400, 499, 4,\n                      500, 599, 5),\n                    ncol = 3, byrow = TRUE)\nreclassif\n\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]  100  199    1\n#&gt; [2,]  200  299    2\n#&gt; [3,]  300  399    3\n#&gt; [4,]  400  499    4\n#&gt; [5,]  500  599    5\n\n\nLes valeurs comprises entre 100 et 199 seront remplacées par la valeur 1. Les valeurs comprises entre 200 et 299 seront remplacées par la valeur 2. Les valeurs comprises entre 300 et 399 seront remplacées par la valeur 3. …\nLa fonction classify() permet de réaliser la reclassification.\n\nclc_5 &lt;- classify(clc, rcl = reclassif)\nplot(clc_5, type = \"classes\")\n\n\n\n\nAffichage avec les intitulés et couleurs officiels des différentes catégories.\n\nplot(\n  clc_5,\n  type = \"classes\",\n  levels = c(\n    \"Territoires artificialisés\",\n    \"Territoires agricoles\",\n    \"Forêts et milieux semi-naturels\",\n    \"Surfaces en eau\"\n  ),\n  col = c(\"#E6004D\",\n          \"#FFFFA8\",\n          \"#80FF00\",\n          \"#00CCF2\"), \n  plg = list(cex = 0.7)\n)\n\n\n\n\n\n\n15.1.4 Opération sur plusieurs couches (ex: NDVI)\nIl est possible de calculer la valeur d’une cellule à partir de ses valeurs stockées dans différentes couches d’un objet SpatRaster.\nL’exemple le plus courant est sans doute le calcul de l’indice de végétation normalisé (NDVI). Pour chaque cellule, on calcule une valeur à partir de deux couches de données matricielles d’une image satellite multispectrale.\n\n# Import d'une image satellite multispectrale\nSentinel2a &lt;- rast(\"data/Sentinel2A.tif\")\n\nCette image satellite multispectrale (résolution de 10m) datée du 12/10/2021, a été produite par le satellite Sentinel-2 et a été récupéré sur la plateforme Copernicus Open Access Hub. Une extraction des bandes spectrales Rouge et proche infrarouge, centrée sur le département du Lot a ensuite été réalisée.\n\nplot(Sentinel2a)\n\n\n\n\nPour alléger le code, on assigne les deux couches matricielles dans des objets SpatRaster différents.\n\n# Bande spectrale rouge\nB04_Red &lt;- Sentinel2a[[1]]\n# Bande spectrale proche infrarouge\nB08_NIR &lt;-Sentinel2a[[2]]\n\nÀ partir de ces deux rasters, nous pouvons calculer l’indice de végétation normalisé :\n\\[{NDVI}=\\frac{\\mathrm{NIR} - \\mathrm{Red}} {\\mathrm{NIR} + \\mathrm{Red}}\\]\n\nraster_NDVI &lt;- (B08_NIR - B04_Red ) / (B08_NIR + B04_Red )\nplot(raster_NDVI)\n\n\n\n\nPlus les valeurs sont importantes (proche de 1), plus la végétation est dense."
  },
  {
    "objectID": "15_algebre_spatial_terra.html#opérations-focales",
    "href": "15_algebre_spatial_terra.html#opérations-focales",
    "title": "15  Algèbre spatial",
    "section": "15.2 Opérations focales",
    "text": "15.2 Opérations focales\n\n\n\nMennis (2015)\n\n\nL’analyse focale considère une cellule plus ses voisins directs de manière contiguë et symétrique (opérations de voisinage). Le plus souvent, la valeur de la cellule de sortie est le résultat d’un bloc de cellules d’entrée 3 x 3 (nombre impair).\nLa première étape consiste à construire une matrice qui détermine le bloc de cellules qui sera pris en compte autour de chaque cellule.\n\n# Matrice 9 x 9, où chaque cellule présente la même pondération\nmon_focal &lt;- matrix(1, nrow = 9, ncol = 9)\nmon_focal\n\n#&gt;       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n#&gt;  [1,]    1    1    1    1    1    1    1    1    1\n#&gt;  [2,]    1    1    1    1    1    1    1    1    1\n#&gt;  [3,]    1    1    1    1    1    1    1    1    1\n#&gt;  [4,]    1    1    1    1    1    1    1    1    1\n#&gt;  [5,]    1    1    1    1    1    1    1    1    1\n#&gt;  [6,]    1    1    1    1    1    1    1    1    1\n#&gt;  [7,]    1    1    1    1    1    1    1    1    1\n#&gt;  [8,]    1    1    1    1    1    1    1    1    1\n#&gt;  [9,]    1    1    1    1    1    1    1    1    1\n\n\nLa fonction focal() permet de ensuite de réaliser l’analyse souhaitée. Par exemple : le calcul de la moyenne des valeurs de toutes les cellules contiguës, pour chaque cellule du raster.\n\nelev_focal_mean &lt;- focal(elev, w = mon_focal, fun = mean)\n\n\nplot(elev, main = \"raster de départ\")\nplot(elev_focal_mean, main=\"résultat : focal 9 x 9)\")\n\n\n\n\n\n\n\n\n\n\n\n\n15.2.1 Opération focales pour rasters d’élévation\nLa fonction terrain() permet de réaliser des analyses focales spécifiques au rasters d’élévation. Six opérations sont disponibles :\n\nslope = calcul de la pente ou degré d’inclinaison de la surface;\naspect = calcul de l’orientation de la pente;\nroughness = calcul de la variabilité ou l’irrégularité de l’élévation;\nTPI = calcul de l’indice des positions topographiques;\nTRI = calcul de l’indice de la variabilité de l’élévation;\nflowdir = calcul du sens d’écoulement de l’eau.\n\nExemples avec le calcul des pentes (slope).\n\n# Calcul de la pente (slope)\nslope &lt;- terrain(elev, \"slope\",\n                 neighbors = 8, # 8 (ou 4) cellules autour pris en compte\n                 unit = \"degrees\") # Unité en sortie\n# Inclinaison des pentes, en degré\nplot(slope)"
  },
  {
    "objectID": "15_algebre_spatial_terra.html#opérations-globales",
    "href": "15_algebre_spatial_terra.html#opérations-globales",
    "title": "15  Algèbre spatial",
    "section": "15.3 Opérations globales",
    "text": "15.3 Opérations globales\n\n\n\nhttps://gisgeography.com/map-algebra-global-zonal-focal-local/\n\n\nLes opérations globales permettent de résumer les valeurs matricielles d’une ou plusieurs matrices.\n\n# Valeur moyenne\nglobal(elev, fun = \"mean\", na.rm = TRUE)\n\n#&gt;              mean\n#&gt; altitude 251.3601\n\n# Écart-type\nglobal(elev, fun = \"sd\", na.rm = TRUE)\n\n#&gt;                sd\n#&gt; altitude 54.58627\n\n# Fréquence\nfreq(clc_5)\n\n#&gt;   layer value count\n#&gt; 1     1     1  3775\n#&gt; 2     1     2 38118\n#&gt; 3     1     3 56331\n#&gt; 4     1     5   928\n\n\nReprésentations statistiques qui résument les informations matricielles.\n\n# Histogramme\nhist(elev)\n\n\n\n\n\n\n\n# Densité\ndensity(elev)\n\n\n\n\n\n\n\n# boxplot\nboxplot(elev)\n\n#&gt; Warning: [boxplot] taking a sample of 1e+05 cells"
  },
  {
    "objectID": "15_algebre_spatial_terra.html#opérations-zonales",
    "href": "15_algebre_spatial_terra.html#opérations-zonales",
    "title": "15  Algèbre spatial",
    "section": "15.4 Opérations zonales",
    "text": "15.4 Opérations zonales\n\n\n\nMennis (2015)\n\n\nLes opérations zonales permettent de résumer les valeurs matricielles de certaines zones (groupe de cellules contiguë dans l’espace ou en valeur).\n\n15.4.1 Opération zonale à partir d’une couche vectorielle\nLa fonction extract() permet d’extraire et de manipuler les valeurs des cellules qui intersectent des données vectorielles.\nExemple à partir de polygones :\n\ncommune &lt;- vect(\"data/lot.gpkg\", layer = \"communes\")\n# Moyenne d'élévation pour chaque polygone (commune) \nelev_by_com &lt;-  extract(elev, commune, fun = mean, na.rm = FALSE)\nhead(elev_by_com, n = 3)\n\n#&gt;   ID altitude\n#&gt; 1  1      NaN\n#&gt; 2  2      NaN\n#&gt; 3  3      NaN\n\nelev_by_com &lt;- elev_by_com[!is.nan(elev_by_com$altitude),]\nelev_by_com$ID &lt;- commune[elev_by_com$ID]$NOM_COM\nhead(elev_by_com, n = 6)\n\n#&gt;                    ID altitude\n#&gt; 7            Arcambal 213.0009\n#&gt; 10             Aujols 216.7961\n#&gt; 23 Belmont-Sainte-Foi 302.4436\n#&gt; 29         Boissières 252.0305\n#&gt; 39             Cahors 205.1988\n#&gt; 41            Caillac 145.9868\n\n\n\n\n15.4.2 Opération zonale à partir d’un raster\nLes opérations zonales peuvent être réaliser par zone délimitée par les valeurs catégorielles d’un second raster. Pour cela, les deux rasters doivent avoir exactement le même étendue et la même résolution.\n\n# Élévation moyenne pour chaque zone de clc\nzonal(elev, clc_5, \"mean\", na.rm = TRUE)\n\n#&gt;   clc altitude\n#&gt; 1   1 209.7177\n#&gt; 2   2 259.3624\n#&gt; 3   3 249.4070\n#&gt; 4   5 115.8435\n\n\n\n\n\n\nLi, X. (2009). Map algebra and beyond : 1. Map algebra for scalar fields. https://slideplayer.com/slide/5822638/.\n\n\nMennis, J. (2015). Fundamentals of GIS : raster operations. https://cupdf.com/document/gus-0262-fundamentals-of-gis-lecture-presentation-7-raster-operations-jeremy.html.\n\n\nTomlin, C. D. (1990). Geographic information systems and cartographic modeling. Prentice Hall."
  },
  {
    "objectID": "16_transformation_terra.html#rasterisation",
    "href": "16_transformation_terra.html#rasterisation",
    "title": "16  Conversions",
    "section": "16.1 Rasterisation",
    "text": "16.1 Rasterisation\nTransformer des polygones en format raster.\n\ncommune &lt;- vect(\"data/lot.gpkg\", layer = \"communes\")\nelev &lt;- rast(\"data/elev.tif\") \n\nraster_commune &lt;- rasterize(x = commune, y = elev , field = \"NOM_COM\")\nplot(raster_commune)\n\n\n\n\nTransformer des points en format raster.\n\n# Rasterisation des centroïdes des communes\nraster_com_centroide &lt;- rasterize(x = centroids(commune), \n                                  y = elev, fun = sum)\nplot(raster_com_centroide)\n\n\n\n\nTransformer des lignes format raster.\n\n# Rasterisation des limites communales\nraster_com_line &lt;- rasterize(x = as.lines(commune), y = elev, fun=sum)\nplot(raster_com_line)\n\n\n\n\n\n16.1.1 Vectorisation\nTransformer un raster en polygones vectoriels.\n\nclc &lt;- rast(\"data/clc.tif\")\nPolygone_Elevation &lt;- as.polygons(clc)\nplot(Polygone_Elevation, y = 1)\n\n\n\n\nTransformer un raster en points vectoriels.\n\nPoints_Elevation &lt;- as.points(clc)\nplot(Points_Elevation, y = 1, cex = 0.3)"
  },
  {
    "objectID": "17_OSM.html",
    "href": "17_OSM.html",
    "title": "17  Focus sur OpenStreetMap",
    "section": "",
    "text": "OpenStreetMap (OSM) est un projet de cartographie participative qui a pour but de constituer une base de données géographiques libre à l’échelle mondiale. OpenStreetMap vous permet de voir, modifier et utiliser des données géographiques dans le monde entier.\nConditions d’utilisation\n\nOpenStreetMap est en données ouvertes : vous êtes libre de l’utiliser pour n’importe quel but tant que vous créditez OpenStreetMap et ses contributeurs. Si vous modifiez ou vous appuyez sur les données d’une façon quelconque, vous pouvez distribuer le résultat seulement suivant la même licence. (…)\n\nContributeurs\n\n(…) Nos contributeurs incluent des cartographes enthousiastes, des professionnels du SIG, des ingénieurs qui font fonctionner les serveurs d’OSM, des humanitaires cartographiant les zones dévastées par une catastrophe et beaucoup d’autres. (…)\n\n\n\n\n\n\n\nA propos d’OpenStreetMap"
  },
  {
    "objectID": "18_OSM_interactif.html#leaflet",
    "href": "18_OSM_interactif.html#leaflet",
    "title": "18  Afficher une carte interactive",
    "section": "18.1 leaflet",
    "text": "18.1 leaflet\n leaflet utilise la libraire javascript Leaflet (Agafonkin, 2015) pour créer des cartes interactives.\n\nlibrary(sf)\n\n#&gt; Linking to GEOS 3.11.1, GDAL 3.6.2, PROJ 9.1.1; sf_use_s2() is TRUE\n\nlibrary(leaflet)\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\nrestaurant &lt;- st_read(\"data/lot.gpkg\", layer = \"restaurants\", quiet = TRUE)\n# Sélection de la commune de Cahors\ncahors &lt;- com[com$INSEE_COM == \"46042\", ]\n# Sélection des restaurants de Cahors\nrestaurant_cahors &lt;- st_filter(restaurant, cahors)\n# transformation du système de coordonnées en WGS84\ncahors &lt;- st_transform(cahors, 4326)\nrestaurant_cahors &lt;- st_transform(restaurant_cahors, 4326)\n\n# Création de la carte interactive\nm &lt;- leaflet(cahors) %&gt;%\n  addTiles() %&gt;%\n  addPolygons() %&gt;%\n  addMarkers(data = restaurant_cahors)\nm\n\n\n\n\n\n\n\n\n\n\n\nSite web de leaflet\n\n\n\nLeaflet for R\n\n\n\n18.1.1 mapview\n mapview s’appuie sur leaflet pour créer des carte interactive, sont utilisation est plus simple et sa documentation est un peu dense.\n\nlibrary(mapview)\nmapview(cahors) + mapview(restaurant_cahors)\n\n\n\n\n\n\n\n\n\n\n\n\nSite web de mapview mapview\n\n\n\n\n\n\n\nAgafonkin, V. (2015). Leaflet javascript libary.\n\n\nAppelhans, T., Detsch, F., Reudenbach, C. et Woellauer, S. (2023). mapview: Interactive Viewing of Spatial Data in R. https://CRAN.R-project.org/package=mapview\n\n\nCheng, J., Schloerke, B., Karambelkar, B. et Xie, Y. (2023). leaflet: Create Interactive Web Maps with the JavaScript ’Leaflet’ Library. https://CRAN.R-project.org/package=leaflet"
  },
  {
    "objectID": "19_OSM_static.html",
    "href": "19_OSM_static.html",
    "title": "19  Importer les fonds de carte raster",
    "section": "",
    "text": "Le package maptiles (Giraud, 2023) permet de télécharger et d’afficher des fonds de cartes raster. La fonction get_tiles() permet de télécharger des fonds de cartes OSM au format SpatRaster du package terra.\nDans cette exemple nous utilisons le package mapsf pour afficher la carte.\nLes rendus sont meilleurs si les données en entrée utilisent le même système de coordonnées que les tuiles (EPSG:3857).\n\nlibrary(sf)\nlibrary(maptiles)\nlibrary(mapsf)\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\ncom &lt;- st_transform(com, 3857)\nosm_tiles &lt;- get_tiles(x = com, zoom = 9, crop = TRUE)\nmf_theme(mar = c(0,0,0,0))\nmf_raster(osm_tiles)\nmf_map(com, border = \"grey20\", col = NA, lwd = .7, add = TRUE)\nmf_credits(get_credit(\"OpenStreetMap\"), bg = \"#ffffff80\")\n\n\n\n\n\n\n\n\nGiraud, T. (2023). maptiles: Download and Display Map Tiles. https://CRAN.R-project.org/package=maptiles"
  },
  {
    "objectID": "20_OSM_data.html#osmdata",
    "href": "20_OSM_data.html#osmdata",
    "title": "20  Importer des données OSM",
    "section": "20.1 osmdata",
    "text": "20.1 osmdata\n Le package osmdata (Mark Padgham et al., 2017) permet d’extraire des données vectorielles depuis OSM en utilisant l’API Overpass turbo.\n\nlibrary(sf)\nlibrary(osmdata)\n\n#&gt; Data (c) OpenStreetMap contributors, ODbL 1.0. https://www.openstreetmap.org/copyright\n\nlibrary(sf)\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\n# Sélection de la commune de Cahors\ncahors &lt;- com[com$INSEE_COM == \"46042\", ]\n# Définition d'une bounding box\nq &lt;- opq(bbox = st_bbox(st_transform(cahors, 4326)))\n# Extraction des restaurants\nreq &lt;- add_osm_feature(opq = q, key = 'amenity', value = \"restaurant\")\nres &lt;- osmdata_sf(req)\n# Reductcion du resultats\n# (les points composant les polygones sont supprimés)\nres &lt;- unique_osmdata(res)\n\nLe résultat contient une couche de points et une couche de polygones. La couche de polygones contient des polygones qui représentent des restaurants. Pour obtenir une couche de points cohérente nous pouvons utiliser les centroides des polygones.\n\nresto_point &lt;- res$osm_points\n# extraire les centroides des polygones\nresto_poly &lt;- res$osm_polygons\nresto_poly_point &lt;- st_centroid(resto_poly)\n\n#&gt; Warning: st_centroid assumes attributes are constant over geometries\n\n# identifier les champs en commun\nchps &lt;- intersect(names(resto_point), names(resto_poly_point))\n# rassembler les 2 objets\nresto &lt;- rbind(resto_point[, chps], resto_poly_point[, chps])\n\nAffichage des résultats\n\nlibrary(mapview)\nmapview(cahors) + mapview(resto)\n\n\n\n\n\n\n\n\n\n\n\n\nSite web d’osmdata\n\n\n\nosmdata"
  },
  {
    "objectID": "20_OSM_data.html#osmextract",
    "href": "20_OSM_data.html#osmextract",
    "title": "20  Importer des données OSM",
    "section": "20.2 osmextract",
    "text": "20.2 osmextract\n Le package osmextract (Gilardi et Lovelace, 2023) permet d’extraire des données depuis une base de données OSM directement. Ce package permet de travailler sur des volumes de données très importants.\n\n\n\n\n\n\nSite web d’osmextract\n\n\n\nosmextract\n\n\n\n\n\n\nGilardi, A. et Lovelace, R. (2023). osmextract: Download and Import Open Street Map Data Extracts. https://CRAN.R-project.org/package=osmextract\n\n\nMark Padgham, Bob Rudis, Robin Lovelace et Maëlle Salmon. (2017). osmdata. Journal of Open Source Software, 2(14), 305. https://doi.org/10.21105/joss.00305"
  },
  {
    "objectID": "21_OSM_routing.html",
    "href": "21_OSM_routing.html",
    "title": "21  Utiliser un engin de routage",
    "section": "",
    "text": "Le package osrm (Giraud, 2022) sert d’interface entre R et le service de calcul d’itinéraire OSRM (Luxen et Vetter, 2011). Ce package permet de calculer des matrices de temps et de distances, des itinéraires routiers, des isochrones. Le package utilise par défaut le serveur de démo d’OSRM. En cas d’utilisation intensive il est fortement recommandé d’utiliser sa propre instance d’OSRM avec Docker.\n\n21.0.1 Calcul d’un itinéraire\nLa fonction osrmRoute() permet de calculer des itinéraires.\n\nlibrary(sf)\nlibrary(osrm)\nlibrary(maptiles)\ncom_raw &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\ncom &lt;- st_transform(com_raw, 3857)\n# Itinéraire entre Cahors et Puybrun\ncahors  &lt;- st_centroid(com[com$INSEE_COM == \"46042\", ])\npuybrun &lt;- st_centroid(com[com$INSEE_COM == \"46229\", ])\nroute &lt;- osrmRoute(src = cahors,\n                   dst = puybrun)\nosm &lt;- get_tiles(st_buffer(route, 2000), crop = TRUE)\nmf_theme(mar = c(0,0,0,0))\nmf_raster(osm)\nmf_map(route, col = \"grey10\", lwd = 6, add = T)\nmf_map(route, col = \"grey90\", lwd = 1, add = T)\n\n\n\n\n\n\n21.0.2 Calcul d’une matrice de temps\nLa fonction osrmTable() permet de calculer des matrices de distances ou de temps par la route.\nDans cet exemple nous calculons une matrice de temps entre 2 adresses et les restaurants de Cahors à pied.\n\nlibrary(sf)\nlibrary(tidygeocoder)\nrestaurant &lt;- st_read(\"data/lot.gpkg\", layer = \"restaurants\", quiet = TRUE)\n# Sélection des restaurants de Cahors\nrestaurant_cahors &lt;- st_filter(restaurant, com_raw[com_raw$INSEE_COM == \"46042\", ])\n# geocodage de 2 adresses à Cahors\nadresses &lt;- data.frame(\n  ad = c(\"3 rue Montaudié, Cahors, France\",\n         \"5 rue Albert Camus, Cahors, France\")\n)\nplaces &lt;- geocode(.tbl = adresses,address = ad, quiet = TRUE)\nplaces &lt;- as.data.frame(places)\nrow.names(places) &lt;- c(\"Rue Montaudié\", \"Rue Albert Camus\")\n# Calcul de la matrice de distance entre les 2 adresses et les restaurants de Cahors\nmat &lt;- osrmTable(src = places[c(3, 2)],\n                 dst = restaurant_cahors,\n                 osrm.profile = \"foot\")\nmat$durations[, 1:5]\n\n#&gt;                     1    2    3    4    5\n#&gt; Rue Montaudié    18.1 21.3 22.2 22.7 14.5\n#&gt; Rue Albert Camus 31.4 63.0 35.4 23.0 32.6\n\n# Quelle adresse possède une meilleurs accessibilité aux restaurants de Cahors?\nboxplot(t(mat$durations), cex.axis = .7, horizontal = TRUE)\n\n\n\n\n\n\n\n\nGiraud, T. (2022). osrm: Interface Between R and the OpenStreetMap-Based Routing Service OSRM. Journal of Open Source Software, 7(78), 4574. https://doi.org/10.21105/joss.04574\n\n\nLuxen, D. et Vetter, C. (2011). Real-time routing with OpenStreetMap data. New York, NY, USA (p. 513‑516). https://doi.org/10.1145/2093973.2094062"
  },
  {
    "objectID": "2000_references.html",
    "href": "2000_references.html",
    "title": "References",
    "section": "",
    "text": "Agafonkin, V. (2015). Leaflet javascript libary.\n\n\nAppelhans, T., Detsch, F., Reudenbach, C. et Woellauer, S. (2023).\nmapview: Interactive Viewing of Spatial Data in R. https://CRAN.R-project.org/package=mapview\n\n\nBivand, R., Keitt, T. et Rowlingson, B. (2023). rgdal: Bindings for\nthe ’Geospatial’ Data Abstraction Library. https://CRAN.R-project.org/package=rgdal\n\n\nBivand, R. et Rundel, C. (2023). rgeos: Interface to Geometry Engine\n- Open Source (’GEOS’). https://CRAN.R-project.org/package=rgeos\n\n\nCambon, J., Hernangómez, D., Belanger, C. et Possenriede, D. (2021).\ntidygeocoder: An R package for geocoding. Journal of Open Source\nSoftware, 6(65), 3544. https://doi.org/10.21105/joss.03544\n\n\nCheng, J., Schloerke, B., Karambelkar, B. et Xie, Y. (2023).\nleaflet: Create Interactive Web Maps with the JavaScript ’Leaflet’\nLibrary. https://CRAN.R-project.org/package=leaflet\n\n\nGDAL/OGR contributors. (2022). GDAL/OGR Geospatial Data\nAbstraction software Library. Open Source Geospatial Foundation. https://doi.org/10.5281/zenodo.5884351\n\n\nGEOS contributors. (2021). GEOS coordinate\ntransformation software library. Open Source Geospatial Foundation.\nhttps://libgeos.org/\n\n\nGilardi, A. et Lovelace, R. (2023). osmextract: Download and Import\nOpen Street Map Data Extracts. https://CRAN.R-project.org/package=osmextract\n\n\nGiraud, T. (2022a). mapsf: Thematic Cartography. https://CRAN.R-project.org/package=mapsf\n\n\nGiraud, T. (2022b). osrm: Interface Between R and the\nOpenStreetMap-Based Routing Service OSRM. Journal of Open\nSource Software, 7(78), 4574. https://doi.org/10.21105/joss.04574\n\n\nGiraud, T. (2023). maptiles: Download and Display Map Tiles. https://CRAN.R-project.org/package=maptiles\n\n\nHijmans, R. J. (2023). terra: Spatial Data Analysis. https://CRAN.R-project.org/package=terra\n\n\nLi, X. (2009). Map algebra and beyond : 1. Map algebra for scalar\nfields. https://slideplayer.com/slide/5822638/.\n\n\nLuxen, D. et Vetter, C. (2011). Real-time routing with OpenStreetMap\ndata. New York, NY, USA (p. 513‑516). https://doi.org/10.1145/2093973.2094062\n\n\nMadelin, M. (2021). Analyse d’images raster (et télédétection). https://mmadelin.github.io/sigr2021/SIGR2021_raster_MM.html.\n\n\nMark Padgham, Bob Rudis, Robin Lovelace et Maëlle Salmon. (2017).\nosmdata. Journal of Open Source Software, 2(14), 305.\nhttps://doi.org/10.21105/joss.00305\n\n\nMennis, J. (2015). Fundamentals of GIS : raster operations. https://cupdf.com/document/gus-0262-fundamentals-of-gis-lecture-presentation-7-raster-operations-jeremy.html.\n\n\nNowosad, J. (2021). Image processing and all things raster. https://nowosad.github.io/SIGR2021/workshop2/workshop2.html.\n\n\nPebesma, E. (2018). Simple Features for R: Standardized Support\nfor Spatial Vector Data. The R Journal,\n10(1), 439‑446. https://doi.org/10.32614/RJ-2018-009\n\n\nPebesma, E. et Bivand, R. (2005). Classes and methods for spatial data\nin R. R News, 5(2), 9‑13. https://CRAN.R-project.org/doc/Rnews/\n\n\nPebesma, E. et Bivand, R. (2023). Spatial Data Science: With\napplications in R (p. 352). Chapman and\nHall/CRC. https://r-spatial.org/book/\n\n\nPROJ contributors. (2021). PROJ coordinate\ntransformation software library. Open Source Geospatial Foundation.\nhttps://proj.org/\n\n\nRacine, E. B. (2016). The Visual Raster Cheat Sheet. https://rpubs.com/etiennebr/visualraster.\n\n\nTomlin, C. D. (1990). Geographic information systems and\ncartographic modeling. Prentice Hall.\n\n\nWalker, K. (2022). crsuggest: Obtain Suggested Coordinate Reference\nSystem Information for Spatial Data. https://CRAN.R-project.org/package=crsuggest\n\n\nWickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L. D.,\nFrançois, R., Grolemund, G., Hayes, A., Henry, L., Hester, J., Kuhn, M.,\nPedersen, T. L., Miller, E., Bache, S. M., Müller, K., Ooms, J.,\nRobinson, D., Seidel, D. P., Spinu, V., Takahashi, K., et\nal.Yutani, H. (2019). Welcome to the tidyverse.\nJournal of Open Source Software, 4(43), 1686. https://doi.org/10.21105/joss.01686"
  },
  {
    "objectID": "2001_donnees.html#à-léchelle-mondiale",
    "href": "2001_donnees.html#à-léchelle-mondiale",
    "title": "Annexe A — Acquisition de données spatiales",
    "section": "A.1 À l’échelle mondiale",
    "text": "A.1 À l’échelle mondiale\n\n rnaturalearth (R-rnaturalearth?) : permet de récupérer les données cartographiques Natural Earth.\n\n gadmr (R-gadmr?) : permet de récupérer les données du GADM (découpages administratifs nationaux et infra-nationaux de l’ensemble des pays du monde).\n\n rgeoboundaries (R-rgeoboundaries?) : client R pour l’API geoBoundaries, fournissant les frontières administratives politiques des pays.\n cshapes (R-cshapes?) : met à disposition les frontières nationales, de 1886 à aujourd’hui.\n\n osmextract (Gilardi et Lovelace, 2023) : permet d’importer des données OpenStreetMap.\n\n osmdata (osmdata2017?) : pour télécharger et utiliser les données d’OpenStreetMap.\n maptiles (Giraud, 2023) : Ce package télécharge, compose et affiche des tuiles à partir d’un grand nombre de fournisseurs (OpenStreetMap, Stamen, Esri, CARTO ou Thunderforest…).\n\n geonames (R-geonames?) : permet d’interroger la BD geonames, qui fournit notamment des localisations.\n wbstats (wbstats2020?) et WDI (R-WDI?) : donnent accès aux données et statistiques de la Banque mondiale.\n\n sen2r (R-sen2r?) : permet de télécharger et prétraiter automatiquement les données du satellite Sentinel-2.\n\n MODIStsp (MODIStsp2016?) : permet de trouver, télécharger et traiter des images MODIS.\n geodata (R-geodata?) : founit un accès à des données sur le climat, l’altitude, le sol, la présence d’espèces et les limites administratives.\n elevatr (R-elevatr?) : donne accès à des données d’élévation mises à disposition par Amazon Web Services Terrain Tiles, l’Open Topography Global Datasets API et l’USGS Elevation Point Query Service.\n rgee (R-rgee?) : permet d’utiliser l’API de Google Earth Engine, catalogue de données publiques et infrastructure de calcul pour les images satellites.\n\n nasapower (nasapower2018?) : API client NASA (prévision des ressources énergétiques mondiales, météorologie, énergie solaire de surface et climatologie).\n geoknife (geoknife2015?) : permet de traiter (en ligne) des données matricielles volumineuses issuent du Geo Data Portal de l’U.S. Geological Survey.\n wopr (R-wopr?) : fournit un accès API à la base de données WorldPop Open Population Repository.\n  rdhs (rdhs2019?) : API client et gestions de données de l’enquête démographique et de santé (DHS)."
  },
  {
    "objectID": "2001_donnees.html#à-léchelle-européenne",
    "href": "2001_donnees.html#à-léchelle-européenne",
    "title": "Annexe A — Acquisition de données spatiales",
    "section": "A.2 À l’échelle européenne",
    "text": "A.2 À l’échelle européenne\n\n giscoR (R-giscoR?) : permet de télécharger des données cartographiques mondiales et européennes de la BD GISCO d’Eurostat (système d’information géographique de la Commission).\n eurostat (eurostat2017?) : permet de télécharger des données de la BD Eurostat."
  },
  {
    "objectID": "2001_donnees.html#à-léchelle-national",
    "href": "2001_donnees.html#à-léchelle-national",
    "title": "Annexe A — Acquisition de données spatiales",
    "section": "A.3 À l’échelle national",
    "text": "A.3 À l’échelle national\n\nBrésil\n\n geobr (R-geobr?) : fournit un accès facile aux séries de données spatiales officielles du Brésil pour différentes années et découpage administratifs.\n\nChili\n\n chilemapas (R-chilemapas?) : donne accès aux divisions politiques et administratives du Chili.\n\nEspagne\n\n mapSpain (R-mapSpain?) : propose les limites administratives de l’Espagne à plusieurs niveaux (Communautés autonomes, Provinces, Municipalités), ainsi que des tuiles.\n\nÉtats-Unis\n\n  tidycensus (R-tidycensus?) : permet de charger des données et géométries du recensement américain en format sf` et `tidyverse\n tigris (R-tigris?) : donne accès aux éléments cartographiques fournis par le US Census Bureau TIGER, y compris les limites cartographiques, les routes et l’eau.\n  FedData (R-FedData?) : automatise le téléchargement de données géospatiales disponibles à partir de plusieurs sources de données fédérées.\n acs (R-acs?) : permet de télécharger et manipuler les données de l’American Community Survey et les données décennales du recensement des États-Unis.\n censusapi (R-censusapi?) : wrapper pour les API du Census Bureau des États-Unis.\n censusGeography (R-censusGeography?) : Permet de convertir les codes géographiques du recensement des États-Unis en nom de lieu.\n idbr (R-idbr?) : interface avec l’API de la base de données internationale du US Census Bureau.\n\n ipumsr (R-ipumsr?) : Permet d’importer des données de recensement, d’enquête et géographiques fournies par l’IPUMS.\n  SeerMapper & co (R-SeerMapper?) : permettent de cartographier des données par États, comtés, secteurs de recensement ou des registres Seer (découpage du recensement 2000 et 2010).\n totalcensus (R-totalcensus?) : permet d’extraire les données du recensement décennal et de l’American Community Survey au niveaux des block, block group et tract.\n  UScensus2010 (R-UScensus2010?), UScensus2000cdp (R-UScensus2000cdp?) et UScensus2000tract (R-UScensus2000tract?) : fournissent les géométries du recensement des États-Unis en 2000/2010, ainsi que des données démographiques supplémentaires.\n\nFinland\n\n mapsFinland (R-mapsFinland?) : donne un accès à des cartes et données concernant la Finland.\n\nFrance\n\n inseeLocalData (R-inseeLocalData?) : client R pour l’API Données Locales de l’Insee.\n insee (R-insee?) : pour télécharger facilement les données de la base BDM (Banque de Données Macroéconomiques) de l’INSEE.\n COGugaison (COGugaison2022?) et CARTElette (R-CARTElette?) : Manipulation, agrégation de données communales françaises et création de couches cartographiques à partir du code officiel géographique (COG) et des couches IGN.\n\nPologne\n\n rgugik (rgugik2021?) : permet l’acquisition automatique de données ouvertes à partir des ressources du Bureau central polonais de la géodésie et de la cartographie (Główny Urząd Geodezji i Kartografii ).\n\n\nRoyaume-Uni\n\n geographr (R-geographr?) : pour manipuler et cartographier les limites géographiques et administratives du Royaume-Uni.\n\nUruguay\n\n geouy (R-geouy?) : permet le chargement d’informations géographiques sur l’Uruguay.\n\n…\n\n\n\n\n\nGilardi, A. et Lovelace, R. (2023). osmextract: Download and Import Open Street Map Data Extracts. https://CRAN.R-project.org/package=osmextract\n\n\nGiraud, T. (2023). maptiles: Download and Display Map Tiles. https://CRAN.R-project.org/package=maptiles"
  },
  {
    "objectID": "2002_data.html#lot.gpkg",
    "href": "2002_data.html#lot.gpkg",
    "title": "Annexe B — Données utilisées",
    "section": "B.1 lot.gpkg",
    "text": "B.1 lot.gpkg\nCe fichier contient plusieurs couches d’informations.\n\ndepartements : les départements français métropolitains, Admin Express COG Carto 3.0, IGN - 2021;\ncommunes : les communes du département du Lot (46) avec des données sur la population active occupée âgée de 25 à 54 ans, par secteur d’activité et sexe, au lieu de résidence, en 2017, BD CARTO® 4.0, IGN - 2021 & Recensements harmonisés - Séries départementales et communales, INSEE - 2020;\nroutes : les routes de la commune de Gramat et alentours (46128), BD CARTO® 4.0, IGN - 2021;\nrestaurants : les restaurants du Lot, Base permanente des équipements (BPE), INSEE - 2021;\nelevations : une grille régulière de points d’altitude (pas d’1 km), Jarvis A., H.I. Reuter, A. Nelson, E. Guevara, 2008, Hole-filled seamless SRTM data V4, International Centre for Tropical Agriculture (CIAT)."
  },
  {
    "objectID": "2002_data.html#com.csv",
    "href": "2002_data.html#com.csv",
    "title": "Annexe B — Données utilisées",
    "section": "B.2 com.csv",
    "text": "B.2 com.csv\nCe fichier tabulaire contient des informations complémentaire sur la population active occupée âgée de 25 à 54 ans, par secteur d’activité et sexe, au lieu de résidence, en 2017, Recensements harmonisés - Séries départementales et communales, INSEE - 2020.\n\nle nombre d’actifs (ACT);\nle nombre d’actifs dans l’industrie (IND);\nla part des actifs dans la population totale (SACT);\nla part des actifs dans l’industrie dans le total des actifs (SACT_IND)."
  },
  {
    "objectID": "2002_data.html#elevation.tif",
    "href": "2002_data.html#elevation.tif",
    "title": "Annexe B — Données utilisées",
    "section": "B.3 elevation.tif",
    "text": "B.3 elevation.tif\nUne grille régulière de points d’altitude (pas de 30 mètres environ), Jarvis A., H.I. Reuter, A. Nelson, E. Guevara, 2008, Hole-filled seamless SRTM data V4, International Centre for Tropical Agriculture (CIAT).\nelev.tif est une version reprojetée en Lambert 93 de elevation.tif"
  },
  {
    "objectID": "2002_data.html#clc_2018.tif",
    "href": "2002_data.html#clc_2018.tif",
    "title": "Annexe B — Données utilisées",
    "section": "B.4 clc_2018.tif",
    "text": "B.4 clc_2018.tif\nDonnées CORINE Land Cover, Corine Land Cover (CLC) 2018, Version 2020_20u1 - Copernicus Programme.\nclc.tif est une version reprojetée en Lambert 93 de clc_2018.tif"
  },
  {
    "objectID": "2002_data.html#sentinel2a.tif",
    "href": "2002_data.html#sentinel2a.tif",
    "title": "Annexe B — Données utilisées",
    "section": "B.5 Sentinel2A.tif",
    "text": "B.5 Sentinel2A.tif\nDonnées Sentinel, Sentinel, Sentinel-2A, S2A_OPER_MSI_L2A_DS_VGS2_20211012T140548_S20211012T105447_N03.01, 12 Octobre 2021 - Copernicus Programme, téléchargé le 28 décembre 2021."
  }
]